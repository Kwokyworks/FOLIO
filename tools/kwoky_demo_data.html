<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOLIO Dummy Data Import</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
        }
        .form-grid {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
            align-items: center;
        }
        .log-table {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }
        .log-table th, .log-table td {
            padding: 12px;
            text-align: left;
        }
        .log-table th {
            background-color: #f3f4f6;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .log-table tr {
            transition: background-color 0.2s;
        }
        .log-table tr:hover {
            background-color: #f9fafb;
        }
        .info { color: #2563eb; }
        .success { color: #15803d; }
        .failure { color: #b91c1c; }
        .warning { color: #d97706; }
        .spinner {
            border: 2px solid #f3f4f6;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        button:focus, select:focus, input:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4 sm:px-6 lg:px-8">
    <div class="max-w-4xl mx-auto bg-white shadow-lg rounded-lg p-6">
        <h1 class="text-2xl font-bold text-gray-900 mb-6">FOLIO Dummy Data Import</h1>
        
        <!-- Form Section -->
        <section class="mb-8">
            <h2 class="text-lg font-semibold text-gray-700 mb-4">Configuration</h2>
            <div class="form-grid">
                <label for="okapiUrl" class="text-gray-600 font-medium">OKAPI Endpoint:</label>
                <div>
                    <select id="okapiUrl" class="w-full p-2 border rounded-md" onchange="toggleCustomUrl()" aria-label="Select OKAPI Endpoint">
                        <option value="https://okapi-demo2.folio.ebsco.com">Demo 2 (okapi-demo2)</option>
                        <option value="https://okapi-demo1.folio.ebsco.com">Demo 1 (okapi-demo1)</option>
                        <option value="https://okapi-utarlibrary.folio.ebsco.com" selected>UTAR Library (okapi-utarlibrary)</option>
                        <option value="custom">Custom URL</option>
                    </select>
                    <input type="text" id="customOkapiUrl" class="w-full p-2 border rounded-md mt-2 hidden" placeholder="Enter custom OKAPI URL" aria-label="Custom OKAPI URL">
                </div>

                <label for="tenantId" class="text-gray-600 font-medium">Tenant ID:</label>
                <div>
                    <select id="tenantId" class="w-full p-2 border rounded-md" onchange="toggleCustomTenant()" aria-label="Select Tenant ID">
                        <option value="fs00001176">fs00001176 (Demo 2)</option>
                        <option value="fs00001175">fs00001175 (Demo 1)</option>
                        <option value="fs00001248" selected>fs00001248 (UTAR Library)</option>
                        <option value="custom">Custom Tenant ID</option>
                    </select>
                    <input type="text" id="customTenantId" class="w-full p-2 border rounded-md mt-2 hidden" placeholder="Enter custom tenant ID" aria-label="Custom Tenant ID">
                </div>

                <label for="username" class="text-gray-600 font-medium">Username:</label>
                <input type="text" id="username" class="w-full p-2 border rounded-md" placeholder="Enter username" required aria-label="Username">

                <label for="password" class="text-gray-600 font-medium">Password:</label>
                <input type="password" id="password" class="w-full p-2 border rounded-md" placeholder="Enter password" required aria-label="Password">

                <label for="locationId" class="text-gray-600 font-medium">Location:</label>
                <select id="locationId" class="w-full p-2 border rounded-md" disabled aria-label="Select Location">
                    <option value="">Login to populate locations</option>
                </select>

                <label for="textTypeId" class="text-gray-600 font-medium">Text Instance Type:</label>
                <select id="textTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Text Instance Type">
                    <option value="">Login to populate instance types</option>
                </select>

                <label for="audioTypeId" class="text-gray-600 font-medium">Audio Instance Type:</label>
                <select id="audioTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Audio Instance Type">
                    <option value="">Login to populate instance types</option>
                </select>

                <label for="bookTypeId" class="text-gray-600 font-medium">Book Material Type:</label>
                <select id="bookTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Book Material Type">
                    <option value="">Login to populate material types</option>
                </select>

                <label for="audiobookTypeId" class="text-gray-600 font-medium">Audiobook Material Type:</label>
                <select id="audiobookTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Audiobook Material Type">
                    <option value="">Login to populate material types</option>
                </select>

                <label for="ebookTypeId" class="text-gray-600 font-medium">E-book Material Type:</label>
                <select id="ebookTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select E-book Material Type">
                    <option value="">Login to populate material types</option>
                </select>

                <label for="loanTypeId" class="text-gray-600 font-medium">Loan Type:</label>
                <select id="loanTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Loan Type">
                    <option value="">Login to populate loan types</option>
                </select>

                <label for="callNumberTypeId" class="text-gray-600 font-medium">Call Number Type:</label>
                <select id="callNumberTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Call Number Type">
                    <option value="">Login to populate call number types</option>
                </select>

                <label for="identifierTypeId" class="text-gray-600 font-medium">Identifier Type:</label>
                <select id="identifierTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Identifier Type">
                    <option value="">Login to populate identifier types</option>
                </select>

                <label for="contributorNameTypeId" class="text-gray-600 font-medium">Contributor Name Type:</label>
                <select id="contributorNameTypeId" class="w-full p-2 border rounded-md" disabled aria-label="Select Contributor Name Type">
                    <option value="">Login to populate contributor name types</option>
                </select>

                <label for="sourceId" class="text-gray-600 font-medium">Holdings Source:</label>
                <select id="sourceId" class="w-full p-2 border rounded-md" disabled aria-label="Select Holdings Source">
                    <option value="">Login to populate holdings sources</option>
                </select>

                <label for="csvUpload" class="text-gray-600 font-medium">Upload CSV:</label>
                <input type="file" id="csvUpload" accept=".csv" class="w-full p-2 border rounded-md" aria-label="Upload CSV File">
            </div>

            <div class="mt-6 flex space-x-4">
                <button id="loginButton" onclick="authenticate()" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition disabled:bg-gray-400" aria-label="Login">Login</button>
                <button id="deleteButton" onclick="confirmDelete()" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition disabled:bg-gray-400" disabled aria-label="Delete Sample Data">Delete Sample Data</button>
                <button id="insertButton" onclick="insertSampleData()" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition disabled:bg-gray-400" disabled aria-label="Insert Sample Data">Insert Sample Data</button>
                <button onclick="downloadCsv()" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 transition" aria-label="Download CSV">Download CSV</button>
            </div>
        </section>

        <!-- Status and Logs Section -->
        <section>
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold text-gray-700">Logs</h2>
                <button onclick="clearLogs()" class="text-blue-600 hover:underline" aria-label="Clear Logs">Clear Logs</button>
            </div>
            <div id="error" class="text-red-600 mb-4" role="alert"></div>
            <div id="loading" class="mb-4 flex items-center space-x-2" aria-live="polite"></div>
            <div class="log-table">
                <table class="w-full text-sm text-gray-700">
                    <thead>
                        <tr>
                            <th class="w-1/6">Timestamp</th>
                            <th class="w-1/6">Type</th>
                            <th class="w-2/3">Message</th>
                        </tr>
                    </thead>
                    <tbody id="status"></tbody>
                </table>
            </div>
        </section>
    </div>

    <script>
        // Dummy data for 10 records
        let dummyData = [
            { part: 1, isbn: "9781234567890", physical: "300 pages ; 24 cm", carrier: "hardcover", barcode: "kwokybc1", callNumber: "LC 12345678901234" },
            { part: 2, isbn: "9781234567891", physical: "250 pages : illustrations ; 20 cm", carrier: "paperback", barcode: "kwokybc2", callNumber: "LC 12345678901235" },
            { part: 3, isbn: "9781234567892", physical: "320 pages ; 25 cm", carrier: "hardcover", barcode: "kwokybc3", callNumber: "LC 12345678901236" },
            { part: 4, isbn: "9781234567893", physical: "1 audio disc (8 hr.) ; 4 3/4 in.", carrier: "audiobook", barcode: "kwokybc4", callNumber: "LC 12345678901237" },
            { part: 5, isbn: "9781234567894", physical: "1 audio disc (9 hr.) ; 4 3/4 in.", carrier: "audiobook", barcode: "kwokybc5", callNumber: "LC 12345678901238" },
            { part: 6, isbn: "9781234567895", physical: "280 pages ; 23 cm", carrier: "hardcover", barcode: "kwokybc6", callNumber: "LC 74345678901239" },
            { part: 7, isbn: "9781234567896", physical: "1 online resource (300 pages) : digital", carrier: "e-book", barcode: "kwokybc7", callNumber: "LC 12345678901240" },
            { part: 8, isbn: "9781234567897", physical: "270 pages : illustrations ; 21 cm", carrier: "paperback", barcode: "kwokybc8", callNumber: "LC 12345678901241" },
            { part: 9, isbn: "9781234567898", physical: "1 online resource (310 pages) : digital", carrier: "e-book", barcode: "kwokybc9", callNumber: "LC 12345678901242" },
            { part: 10, isbn: "9781234567899", physical: "350 pages ; 24 cm", carrier: "hardcover", barcode: "kwokybc10", callNumber: "LC 12345678901243" }
        ];

        let authToken = null;
        let folioConfig = {
            mainLocation: null,
            textType: null,
            audioType: null,
            bookType: null,
            audiobookType: null,
            ebookType: null,
            isbnType: null,
            personalNameType: null,
            canCirculateType: null,
            callNumberTypeId: null,
            sourceId: null
        };

        // Toggle custom OKAPI URL input visibility
        function toggleCustomUrl() {
            const okapiSelect = document.getElementById('okapiUrl');
            const customUrlInput = document.getElementById('customOkapiUrl');
            customUrlInput.classList.toggle('hidden', okapiSelect.value !== 'custom');
        }

        // Toggle custom tenant ID input visibility
        function toggleCustomTenant() {
            const tenantSelect = document.getElementById('tenantId');
            const customTenantInput = document.getElementById('customTenantId');
            customTenantInput.classList.toggle('hidden', tenantSelect.value !== 'custom');
        }

        // Get OKAPI URL from input
        function getOkapiUrl() {
            const okapiSelect = document.getElementById('okapiUrl');
            if (okapiSelect.value === 'custom') {
                const customUrl = document.getElementById('customOkapiUrl').value.trim();
                if (!customUrl) throw new Error('Custom OKAPI URL is required.');
                if (!customUrl.match(/^https?:\/\/.+/)) throw new Error('Invalid OKAPI URL format.');
                return customUrl;
            }
            return okapiSelect.value;
        }

        // Get Tenant ID from input
        function getTenantId() {
            const tenantSelect = document.getElementById('tenantId');
            if (tenantSelect.value === 'custom') {
                const customTenant = document.getElementById('customTenantId').value.trim();
                if (!customTenant) throw new Error('Custom Tenant ID is required.');
                return customTenant;
            }
            return tenantSelect.value;
        }

        // Download dummy data as CSV
        function downloadCsv() {
            const headers = ['part', 'isbn', 'physical', 'carrier', 'barcode', 'callNumber'];
            const csvRows = [headers.join(',')];
            dummyData.forEach(record => {
                const values = [
                    record.part,
                    `"${record.isbn}"`,
                    `"${record.physical.replace(/"/g, '""')}"`,
                    record.carrier,
                    record.barcode,
                    `"${record.callNumber}"`
                ];
                csvRows.push(values.join(','));
            });
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'folio_dummy_data.csv';
            a.click();
            URL.revokeObjectURL(url);
            logMessage('success', 'Downloaded dummy data as CSV');
        }

        // Handle CSV upload
        document.getElementById('csvUpload').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');
            errorDiv.textContent = '';
            loadingDiv.innerHTML = '<span class="spinner"></span> Processing CSV file...';

            try {
                const text = await file.text();
                const rows = text.split('\n').map(row => row.trim()).filter(row => row);
                if (rows.length < 1) throw new Error('CSV file is empty.');

                const headers = rows[0].split(',').map(h => h.trim());
                const expectedHeaders = ['part', 'isbn', 'physical', 'carrier', 'barcode', 'callNumber'];
                if (!expectedHeaders.every((h, i) => h === headers[i])) {
                    throw new Error('Invalid CSV headers. Expected: ' + expectedHeaders.join(', '));
                }

                const newData = [];
                for (let i = 1; i < rows.length; i++) {
                    const values = rows[i].split(',').map(v => v.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
                    if (values.length !== expectedHeaders.length) {
                        throw new Error(`Invalid row ${i + 1}: Expected ${expectedHeaders.length} columns.`);
                    }
                    const part = parseInt(values[0]);
                    if (isNaN(part)) throw new Error(`Invalid part number in row ${i + 1}.`);
                    newData.push({
                        part,
                        isbn: values[1],
                        physical: values[2],
                        carrier: values[3],
                        barcode: values[4],
                        callNumber: values[5]
                    });
                }

                if (newData.length === 0) throw new Error('No valid data rows found in CSV.');
                dummyData = newData;
                loadingDiv.innerHTML = '';
                logMessage('success', `Uploaded CSV with ${newData.length} records`, newData.map(d => ({ name: `Part ${d.part}` })));
            } catch (error) {
                errorDiv.textContent = `Error processing CSV: ${error.message}`;
                loadingDiv.innerHTML = '';
                logMessage('failure', 'Failed to process CSV', [{ name: error.message }]);
            }

            event.target.value = '';
        });

        // Log message to table
        function logMessage(type, message, items = []) {
            const statusTable = document.getElementById('status');
            const row = document.createElement('tr');
            const timestamp = new Date().toLocaleTimeString();
            const itemText = Array.isArray(items) && items.length > 0
                ? items.map(i => i.name ? `${i.name} (${i.id || 'no-id'})` : JSON.stringify(i)).join(', ')
                : 'None';
            row.innerHTML = `
                <td>${timestamp}</td>
                <td class="${type} capitalize">${type}</td>
                <td>${message}: ${itemText}</td>
            `;
            statusTable.prepend(row);
        }

        // Clear logs
        function clearLogs() {
            document.getElementById('status').innerHTML = '';
            logMessage('info', 'Logs cleared');
        }

        function updateButtonStates(loggedIn) {
            document.getElementById('loginButton').disabled = loggedIn;
            document.getElementById('deleteButton').disabled = !loggedIn;
            document.getElementById('insertButton').disabled = !loggedIn;
        }

        // Populate dropdown with options
        function populateDropdown(selectId, items, valueKey, labelKey) {
            const select = document.getElementById(selectId);
            select.innerHTML = '';
            if (!Array.isArray(items) || items.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No options available';
                select.appendChild(option);
                select.disabled = true;
                return;
            }
            items.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[labelKey] + ` (${item[valueKey]})`;
                select.appendChild(option);
            });
            select.disabled = false;
        }

        // Fetch configuration (all UUIDs)
        async function fetchConfig(okapiUrl, tenantId, token) {
            const headers = {
                'x-okapi-tenant': tenantId,
                'x-okapi-token': token,
                'Accept': 'application/json'
            };

            const config = {
                locations: [],
                instanceTypes: [],
                materialTypes: [],
                loanTypes: [],
                callNumberTypes: [],
                identifierTypes: [],
                contributorNameTypes: []
            };

            try {
                // Fetch locations
                try {
                    const locationsResponse = await fetch(`${okapiUrl}/locations?limit=1000`, { headers });
                    if (!locationsResponse.ok) {
                        const errorText = await locationsResponse.text();
                        throw new Error(`Failed to fetch locations: ${locationsResponse.status} ${errorText}`);
                    }
                    const locationsData = await locationsResponse.json();
                    if (!Array.isArray(locationsData.locations)) {
                        logMessage('failure', 'Invalid locations response', [{ name: 'Missing or invalid "locations" property' }]);
                        throw new Error('Invalid locations response: Missing or invalid "locations" property');
                    }
                    config.locations = locationsData.locations;
                    logMessage('info', 'Available locations', config.locations);
                    if (!config.locations.length) throw new Error('No locations found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch locations', [{ name: error.message }]);
                    throw error;
                }

                // Fetch instance types
                try {
                    const instanceTypesResponse = await fetch(`${okapiUrl}/instance-types?limit=1000`, { headers });
                    if (!instanceTypesResponse.ok) {
                        const errorText = await instanceTypesResponse.text();
                        throw new Error(`Failed to fetch instance types: ${instanceTypesResponse.status} ${errorText}`);
                    }
                    const instanceTypesData = await instanceTypesResponse.json();
                    if (!Array.isArray(instanceTypesData.instanceTypes)) {
                        logMessage('failure', 'Invalid instance types response', [{ name: 'Missing or invalid "instanceTypes" property' }]);
                        throw new Error('Invalid instance types response: Missing or invalid "instanceTypes" property');
                    }
                    config.instanceTypes = instanceTypesData.instanceTypes;
                    logMessage('info', 'Available instance types', config.instanceTypes);
                    if (!config.instanceTypes.length) throw new Error('No instance types found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch instance types', [{ name: error.message }]);
                    throw error;
                }

                // Fetch material types
                try {
                    const materialTypesResponse = await fetch(`${okapiUrl}/material-types?limit=1000`, { headers });
                    if (!materialTypesResponse.ok) {
                        const errorText = await materialTypesResponse.text();
                        throw new Error(`Failed to fetch material types: ${materialTypesResponse.status} ${errorText}`);
                    }
                    const materialTypesData = await materialTypesResponse.json();
                    if (!Array.isArray(materialTypesData.mtypes)) {
                        logMessage('failure', 'Invalid material types response', [{ name: 'Missing or invalid "mtypes" property' }]);
                        throw new Error('Invalid material types response: Missing or invalid "mtypes" property');
                    }
                    config.materialTypes = materialTypesData.mtypes;
                    logMessage('info', 'Available material types', config.materialTypes);
                    if (!config.materialTypes.length) throw new Error('No material types found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch material types', [{ name: error.message }]);
                    throw error;
                }

                // Fetch loan types
                try {
                    const loanTypesResponse = await fetch(`${okapiUrl}/loan-types?limit=1000`, { headers });
                    if (!loanTypesResponse.ok) {
                        const errorText = await loanTypesResponse.text();
                        throw new Error(`Failed to fetch loan types: ${loanTypesResponse.status} ${errorText}`);
                    }
                    const loanTypesData = await loanTypesResponse.json();
                    const loanTypesKey = loanTypesData.loanTypes ? 'loanTypes' : 'loantypes';
                    if (!Array.isArray(loanTypesData[loanTypesKey])) {
                        logMessage('failure', 'Invalid loan types response', [{ name: `Missing or invalid "${loanTypesKey}" property` }]);
                        throw new Error(`Invalid loan types response: Missing or invalid "${loanTypesKey}" property`);
                    }
                    config.loanTypes = loanTypesData[loanTypesKey];
                    logMessage('info', `Available loan types (using "${loanTypesKey}" key)`, config.loanTypes);
                    if (!config.loanTypes.length) {
                        logMessage('warning', 'No loan types found in the tenant');
                    }
                } catch (error) {
                    logMessage('failure', 'Failed to fetch loan types', [{ name: error.message }]);
                    throw error;
                }

                // Fetch call number types
                try {
                    const callNumberTypesResponse = await fetch(`${okapiUrl}/call-number-types?limit=1000`, { headers });
                    if (!callNumberTypesResponse.ok) {
                        const errorText = await callNumberTypesResponse.text();
                        throw new Error(`Failed to fetch call number types: ${callNumberTypesResponse.status} ${errorText}`);
                    }
                    const callNumberTypesData = await callNumberTypesResponse.json();
                    if (!Array.isArray(callNumberTypesData.callNumberTypes)) {
                        logMessage('failure', 'Invalid call number types response', [{ name: 'Missing or invalid "callNumberTypes" property' }]);
                        throw new Error('Invalid call number types response: Missing or invalid "callNumberTypes" property');
                    }
                    config.callNumberTypes = callNumberTypesData.callNumberTypes;
                    logMessage('info', 'Available call number types', config.callNumberTypes);
                    if (!config.callNumberTypes.length) throw new Error('No call number types found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch call number types', [{ name: error.message }]);
                    throw error;
                }

                // Fetch identifier types
                try {
                    const identifierTypesResponse = await fetch(`${okapiUrl}/identifier-types?limit=1000`, { headers });
                    if (!identifierTypesResponse.ok) {
                        const errorText = await identifierTypesResponse.text();
                        throw new Error(`Failed to fetch identifier types: ${identifierTypesResponse.status} ${errorText}`);
                    }
                    const identifierTypesData = await identifierTypesResponse.json();
                    if (!Array.isArray(identifierTypesData.identifierTypes)) {
                        logMessage('failure', 'Invalid identifier types response', [{ name: 'Missing or invalid "identifierTypes" property' }]);
                        throw new Error('Invalid identifier types response: Missing or invalid "identifierTypes" property');
                    }
                    config.identifierTypes = identifierTypesData.identifierTypes;
                    logMessage('info', 'Available identifier types', config.identifierTypes);
                    if (!config.identifierTypes.length) throw new Error('No identifier types found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch identifier types', [{ name: error.message }]);
                    throw error;
                }

                // Fetch contributor name types
                try {
                    const contributorNameTypesResponse = await fetch(`${okapiUrl}/contributor-name-types?limit=1000`, { headers });
                    if (!contributorNameTypesResponse.ok) {
                        const errorText = await contributorNameTypesResponse.text();
                        throw new Error(`Failed to fetch contributor name types: ${contributorNameTypesResponse.status} ${errorText}`);
                    }
                    const contributorNameTypesData = await contributorNameTypesResponse.json();
                    if (!Array.isArray(contributorNameTypesData.contributorNameTypes)) {
                        logMessage('failure', 'Invalid contributor name types response', [{ name: 'Missing or invalid "contributorNameTypes" property' }]);
                        throw new Error('Invalid contributor name types response: Missing or invalid "contributorNameTypes" property');
                    }
                    config.contributorNameTypes = contributorNameTypesData.contributorNameTypes;
                    logMessage('info', 'Available contributor name types', config.contributorNameTypes);
                    if (!config.contributorNameTypes.length) throw new Error('No contributor name types found in the tenant.');
                } catch (error) {
                    logMessage('failure', 'Failed to fetch contributor name types', [{ name: error.message }]);
                    throw error;
                }

                return config;
            } catch (error) {
                throw new Error(`Error fetching configuration: ${error.message}`);
            }
        }

        async function authenticate() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');

            errorDiv.textContent = '';
            loadingDiv.innerHTML = '<span class="spinner"></span> Authenticating...';

            if (!username || !password) {
                errorDiv.textContent = 'Please enter both username and password.';
                loadingDiv.innerHTML = '';
                return;
            }

            let OKAPI_URL, TENANT_ID;
            try {
                OKAPI_URL = getOkapiUrl();
                TENANT_ID = getTenantId();
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                loadingDiv.innerHTML = '';
                return;
            }

            try {
                const loginResponse = await fetch(`${OKAPI_URL}/authn/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-okapi-tenant': TENANT_ID
                    },
                    body: JSON.stringify({ username, password })
                });

                if (loginResponse.status !== 201) {
                    throw new Error(`Authentication failed: ${loginResponse.status} ${loginResponse.statusText}`);
                }

                authToken = loginResponse.headers.get('x-okapi-token');
                if (!authToken) {
                    throw new Error('No x-okapi-token received in response.');
                }

                const headers = {
                    'x-okapi-tenant': TENANT_ID,
                    'x-okapi-token': authToken,
                    'Accept': 'application/json'
                };

                // Fetch configuration
                loadingDiv.innerHTML = '<span class="spinner"></span> Fetching configuration...';
                let config;
                try {
                    config = await fetchConfig(OKAPI_URL, TENANT_ID, authToken);
                } catch (error) {
                    errorDiv.textContent = `Error fetching configuration: ${error.message}`;
                    loadingDiv.innerHTML = '';
                    authToken = null;
                    return;
                }

                // Populate dropdowns
                populateDropdown('locationId', config.locations, 'id', 'name');
                populateDropdown('textTypeId', config.instanceTypes, 'id', 'name');
                populateDropdown('audioTypeId', config.instanceTypes, 'id', 'name');
                populateDropdown('bookTypeId', config.materialTypes, 'id', 'name');
                populateDropdown('audiobookTypeId', config.materialTypes, 'id', 'name');
                populateDropdown('ebookTypeId', config.materialTypes, 'id', 'name');
                populateDropdown('loanTypeId', config.loanTypes, 'id', 'name');
                populateDropdown('callNumberTypeId', config.callNumberTypes, 'id', 'name');
                populateDropdown('identifierTypeId', config.identifierTypes, 'id', 'name');
                populateDropdown('contributorNameTypeId', config.contributorNameTypes, 'id', 'name');

                // Fetch holdings sources
                loadingDiv.innerHTML = '<span class="spinner"></span> Fetching holdings sources...';
                try {
                    const holdingsSourcesResponse = await fetch(`${OKAPI_URL}/holdings-sources?query=cql.allRecords=1%20sortby%20name&limit=2000`, { headers });
                    if (!holdingsSourcesResponse.ok) {
                        const errorText = await holdingsSourcesResponse.text();
                        throw new Error(`Failed to fetch holdings sources: ${holdingsSourcesResponse.status} ${errorText}`);
                    }
                    const holdingsSourcesData = await holdingsSourcesResponse.json();
                    if (!Array.isArray(holdingsSourcesData.holdingsRecordsSources)) {
                        logMessage('failure', 'Invalid holdings sources response', [{ name: 'Missing or invalid "holdingsRecordsSources" property' }]);
                        throw new Error('Invalid holdings sources response: Missing or invalid "holdingsRecordsSources" property');
                    }
                    const holdingsSources = holdingsSourcesData.holdingsRecordsSources;
                    logMessage('info', 'Available holdings sources', holdingsSources);
                    populateDropdown('sourceId', holdingsSources, 'id', 'name');
                } catch (error) {
                    errorDiv.textContent = `Error fetching holdings sources: ${error.message}. Please contact tenant admin for the FOLIO source ID.`;
                    loadingDiv.innerHTML = '';
                    authToken = null;
                    return;
                }

                updateButtonStates(true);
                loadingDiv.innerHTML = '';
                logMessage('success', 'Successfully logged in');
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                loadingDiv.innerHTML = '';
                authToken = null;
                updateButtonStates(false);
            }
        }

        function confirmDelete() {
            if (confirm('Are you sure you want to delete all sample data? This action cannot be undone.')) {
                deleteSampleData();
            }
        }

        async function deleteSampleData() {
            if (!authToken) {
                document.getElementById('error').textContent = 'Please login first.';
                return;
            }

            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');

            errorDiv.textContent = '';
            loadingDiv.innerHTML = '<span class="spinner"></span> Deleting existing records...';

            let OKAPI_URL, TENANT_ID;
            try {
                OKAPI_URL = getOkapiUrl();
                TENANT_ID = getTenantId();
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                loadingDiv.innerHTML = '';
                return;
            }

            const headers = {
                'x-okapi-tenant': TENANT_ID,
                'x-okapi-token': authToken,
                'Accept': 'text/plain'
            };

            try {
                const query = encodeURIComponent('title=="FOLIO adventures*"');
                const instancesResponse = await fetch(`${OKAPI_URL}/inventory/instances?query=${query}&limit=1000`, {
                    headers: { ...headers, 'Accept': 'application/json' }
                });
                if (!instancesResponse.ok) {
                    const errorText = await instancesResponse.text();
                    throw new Error(`Failed to query instances: ${instancesResponse.status} ${errorText}`);
                }
                const instancesData = await instancesResponse.json();
                const instances = Array.isArray(instancesData.instances) ? instancesData.instances : [];
                logMessage('info', 'Found existing instances', instances);

                for (const instance of instances) {
                    try {
                        const holdingsQuery = encodeURIComponent(`instanceId==${instance.id}`);
                        const holdingsResponse = await fetch(`${OKAPI_URL}/holdings-storage/holdings?query=${holdingsQuery}&limit=1000`, {
                            headers: { ...headers, 'Accept': 'application/json' }
                        });
                        if (!holdingsResponse.ok) {
                            const errorText = await holdingsResponse.text();
                            throw new Error(`Failed to query holdings for instance ${instance.id}: ${holdingsResponse.status} ${errorText}`);
                        }
                        const holdingsData = await holdingsResponse.json();
                        const holdings = Array.isArray(holdingsData.holdingsRecords) ? holdingsData.holdingsRecords : [];
                        logMessage('info', `Found holdings for instance ${instance.id}`, holdings);

                        for (const holding of holdings) {
                            try {
                                const itemsQuery = encodeURIComponent(`holdingsRecordId==${holding.id}`);
                                const itemsResponse = await fetch(`${OKAPI_URL}/item-storage/items?query=${itemsQuery}&limit=1000`, {
                                    headers: { ...headers, 'Accept': 'application/json' }
                                });
                                if (!itemsResponse.ok) {
                                    const errorText = await itemsResponse.text();
                                    throw new Error(`Failed to query items for holdings ${holding.id}: ${itemsResponse.status} ${errorText}`);
                                }
                                const itemsData = await itemsResponse.json();
                                const items = Array.isArray(itemsData.items) ? itemsData.items : [];
                                logMessage('info', `Found items for holdings ${holding.id}`, items);

                                for (const item of items) {
                                    const deleteItemResponse = await fetch(`${OKAPI_URL}/item-storage/items/${item.id}`, {
                                        method: 'DELETE',
                                        headers
                                    });
                                    if (!deleteItemResponse.ok) {
                                        const errorText = await deleteItemResponse.text();
                                        throw new Error(`Failed to delete item ${item.id}: ${deleteItemResponse.status} ${errorText}`);
                                    }
                                    logMessage('info', `Deleted item`, [{ name: item.id }]);
                                }

                                const deleteHoldingResponse = await fetch(`${OKAPI_URL}/holdings-storage/holdings/${holding.id}`, {
                                    method: 'DELETE',
                                    headers
                                });
                                if (!deleteHoldingResponse.ok) {
                                    const errorText = await deleteHoldingResponse.text();
                                    throw new Error(`Failed to delete holdings ${holding.id}: ${deleteHoldingResponse.status} ${errorText}`);
                                }
                                logMessage('info', `Deleted holdings`, [{ name: holding.id }]);
                            } catch (err) {
                                logMessage('failure', `Error deleting holdings ${holding.id}`, [{ name: err.message }]);
                            }
                        }

                        const deleteInstanceResponse = await fetch(`${OKAPI_URL}/inventory/instances/${instance.id}`, {
                            method: 'DELETE',
                            headers
                        });
                        if (!deleteInstanceResponse.ok) {
                            const errorText = await deleteInstanceResponse.text();
                            throw new Error(`Failed to delete instance ${instance.id}: ${deleteInstanceResponse.status} ${errorText}`);
                        }
                        logMessage('info', `Deleted instance`, [{ name: instance.id }]);
                    } catch (err) {
                        logMessage('failure', `Error deleting instance ${instance.id}`, [{ name: err.message }]);
                    }
                }

                loadingDiv.innerHTML = '';
                logMessage('success', 'Successfully deleted sample data');
            } catch (err) {
                errorDiv.textContent = `Error during deletion: ${err.message}.`;
                loadingDiv.innerHTML = '';
            }
        }

        async function insertSampleData() {
            if (!authToken) {
                document.getElementById('error').textContent = 'Please login first.';
                return;
            }

            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');

            errorDiv.textContent = '';
            loadingDiv.innerHTML = '<span class="spinner"></span> Inserting dummy records...';

            let OKAPI_URL, TENANT_ID;
            try {
                OKAPI_URL = getOkapiUrl();
                TENANT_ID = getTenantId();
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                loadingDiv.innerHTML = '';
                return;
            }

            // Get selected UUIDs from dropdowns
            const selectedConfig = {
                mainLocation: document.getElementById('locationId').value,
                textType: document.getElementById('textTypeId').value,
                audioType: document.getElementById('audioTypeId').value,
                bookType: document.getElementById('bookTypeId').value,
                audiobookType: document.getElementById('audiobookTypeId').value,
                ebookType: document.getElementById('ebookTypeId').value,
                canCirculateType: document.getElementById('loanTypeId').value,
                callNumberTypeId: document.getElementById('callNumberTypeId').value,
                isbnType: document.getElementById('identifierTypeId').value,
                personalNameType: document.getElementById('contributorNameTypeId').value,
                sourceId: document.getElementById('sourceId').value
            };

            // Validate selections
            if (!Object.values(selectedConfig).every(v => v)) {
                errorDiv.textContent = 'Please select all required types from the dropdowns.';
                loadingDiv.innerHTML = '';
                return;
            }

            const headers = {
                'x-okapi-tenant': TENANT_ID,
                'x-okapi-token': authToken,
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            };

            const selectedUUIDs = [
                { name: `mainLocation: ${selectedConfig.mainLocation}` },
                { name: `textType: ${selectedConfig.textType}` },
                { name: `audioType: ${selectedConfig.audioType}` },
                { name: `bookType: ${selectedConfig.bookType}` },
                { name: `audiobookType: ${selectedConfig.audiobookType}` },
                { name: `ebookType: ${selectedConfig.ebookType}` },
                { name: `canCirculateType: ${selectedConfig.canCirculateType}` },
                { name: `callNumberTypeId: ${selectedConfig.callNumberTypeId}` },
                { name: `isbnType: ${selectedConfig.isbnType}` },
                { name: `personalNameType: ${selectedConfig.personalNameType}` },
                { name: `sourceId: ${selectedConfig.sourceId}` }
            ];
            logMessage('info', 'Selected UUIDs', selectedUUIDs);

            for (const record of dummyData) {
                try {
                    const instance = {
                        id: crypto.randomUUID(),
                        title: `FOLIO adventures part ${record.part}`,
                        source: 'Manual',
                        instanceTypeId: record.carrier === 'audiobook' ? selectedConfig.audioType : selectedConfig.textType,
                        identifiers: [{ identifierTypeId: selectedConfig.isbnType, value: record.isbn }],
                        contributors: [{ contributorNameTypeId: selectedConfig.personalNameType, name: 'Smith, John' }],
                        publication: [{ publisher: 'FOLIO Press', place: 'New York', dateOfPublication: '2025' }],
                        physicalDescriptions: [record.physical],
                        materialTypeId: record.carrier === 'audiobook' ? selectedConfig.audiobookType : record.carrier === 'e-book' ? selectedConfig.ebookType : selectedConfig.bookType
                    };
                    const instanceResponse = await fetch(`${OKAPI_URL}/inventory/instances`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(instance)
                    });
                    if (!instanceResponse.ok) {
                        const errorData = await instanceResponse.json().catch(() => ({}));
                        throw new Error(`Failed to create instance: ${instanceResponse.status} ${instanceResponse.statusText} - ${JSON.stringify(errorData)}`);
                    }
                    logMessage('info', `Created instance for part ${record.part}`, [{ name: instance.id }]);

                    const holdings = {
                        id: crypto.randomUUID(),
                        instanceId: instance.id,
                        permanentLocationId: selectedConfig.mainLocation,
                        callNumber: record.callNumber,
                        callNumberTypeId: selectedConfig.callNumberTypeId,
                        sourceId: selectedConfig.sourceId
                    };
                    const holdingsResponse = await fetch(`${OKAPI_URL}/holdings-storage/holdings`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(holdings)
                    });
                    if (!holdingsResponse.ok) {
                        const errorData = await holdingsResponse.json().catch(() => ({}));
                        throw new Error(`Failed to create holdings: ${holdingsResponse.status} ${holdingsResponse.statusText} - ${JSON.stringify(errorData)}`);
                    }
                    logMessage('info', `Created holdings for part ${record.part}`, [{ name: holdings.id }]);

                    const item = {
                        id: crypto.randomUUID(),
                        hrid: `item_${record.barcode}`,
                        holdingsRecordId: holdings.id,
                        barcode: record.barcode,
                        materialTypeId: instance.materialTypeId,
                        permanentLoanTypeId: selectedConfig.canCirculateType,
                        status: { name: 'Available' }
                    };
                    const itemResponse = await fetch(`${OKAPI_URL}/item-storage/items`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(item)
                    });
                    if (!itemResponse.ok) {
                        const errorData = await itemResponse.json().catch(() => ({}));
                        throw new Error(`Failed to create item: ${itemResponse.status} ${itemResponse.statusText} - ${JSON.stringify(errorData)}`);
                    }
                    logMessage('info', `Created item for part ${record.part}`, [{ name: item.id }]);

                    logMessage('success', `Successfully created record for part ${record.part}`);
                } catch (error) {
                    logMessage('failure', `Failed to create record for part ${record.part}`, [{ name: error.message }]);
                }
            }

            loadingDiv.innerHTML = '';
        }
    </script>
</body>
</html>